# Transactions

The testing framework follows the Transaction definitions described in [`algorand-python` docs](https://algorand-python.readthedocs.io/en/latest/algorand_sdk/transactions.html). Which implies that transaction related abstractions fall under the following categories:

## `algopy.Txn` opcode

In contrast with [`algopy.Global`](state-management#Global), `algopy.Txn` opcode provides access to transactions submitted by the current executing transaction.

### `scoped_txn_fields`:

`scoped_txn_fields` is a context manager property available on test context instance that allows setting temporary transaction fields within a specific scope. It's defined in the AlgopyTestContext class:

```python
import algopy
from algopy_testing import AlgopyTestContext, algopy_testing_context

class SimpleContract(algopy.ARC4Contract):
    @algopy.arc4.abimethod
    def check_sender(self) -> algopy.Bytes:
        return algopy.Txn.sender

# Create a test context
with algopy_testing_context() as ctx:
    # Create a contract instance
    contract = SimpleContract()
    # Use scoped_txn_fields to temporarily change the sender
    patched_sender = ctx.any_account()
    with ctx.scoped_txn_fields(sender=patched_sender):
        # Call the contract method
        result = contract.check_sender()

        # Assert that the sender is the default creator
        assert result == patched_sender
```

The `scoped_txn_fields` context manager temporarily sets transaction fields and restores them to their previous values when exiting the context. This is useful for applying specific transaction fields for a limited scope without affecting the global state.

## Group Transactions

Refers to transaction abstractions available under `algopy.gtxn.*` namespace.

```python
... # instantiate test context

# Generate a random payment transaction
pay_txn = ctx.any_payment_transaction(
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    receiver=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    amount=algopy.UInt64(1000000)  # Specified amount
)

# Generate a random asset transfer transaction
asset_transfer_txn = ctx.any_asset_transfer_transaction(
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    receiver=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    asset_id=algopy.UInt64(1),  # Specified asset ID
    amount=algopy.UInt64(1000)  # Specified amount
)

# Generate a random application call transaction
app_call_txn = ctx.any_application_call_transaction(
    app_id=ctx.any_application(),  # Defaults to a random application generated by ctx.any_application()
    app_args=[algopy.Bytes(b"arg1"), algopy.Bytes(b"arg2")],  # Specified application arguments
    accounts=[ctx.any_account()],  # Defaults to a list with a single random account generated by ctx.any_account()
    assets=[ctx.any_asset()],  # Defaults to a list with a single random asset generated by ctx.any_asset()
    apps=[ctx.any_application()],  # Defaults to a list with a single random application generated by ctx.any_application()
    approval_program_pages=[algopy.Bytes(b"approval_code")],  # Specified approval program pages
    clear_state_program_pages=[algopy.Bytes(b"clear_code")],  # Specified clear state program pages
    scratch_space={0: algopy.Bytes(b"scratch")}  # Specified scratch space
)

# Generate a random asset config transaction
asset_config_txn = ctx.any_asset_config_transaction(
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    asset_id=algopy.UInt64(1),  # Specified asset ID
    params=algopy.AssetParams(
        total=1000000,  # Specified total
        decimals=0,  # Specified decimals
        default_frozen=False,  # Specified default frozen state
        unit_name="UNIT",  # Specified unit name
        asset_name="Asset",  # Specified asset name
        url="http://asset-url",  # Specified URL
        metadata_hash=b"metadata_hash",  # Specified metadata hash
        manager=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
        reserve=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
        freeze=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
        clawback=ctx.any_account()  # Defaults to a random account generated by ctx.any_account()
    )
)

# Generate a random key registration transaction
key_reg_txn = ctx.any_key_registration_transaction(
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    vote_pk=algopy.Bytes(b"vote_pk"),  # Specified vote public key
    selection_pk=algopy.Bytes(b"selection_pk"),  # Specified selection public key
    vote_first=algopy.UInt64(1),  # Specified vote first round
    vote_last=algopy.UInt64(1000),  # Specified vote last round
    vote_key_dilution=algopy.UInt64(10000)  # Specified vote key dilution
)

# Generate a random asset freeze transaction
asset_freeze_txn = ctx.any_asset_freeze_transaction(
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    asset_id=algopy.UInt64(1),  # Specified asset ID
    freeze_target=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    freeze_state=True  # Specified freeze state
)

# Generate a random transaction of a specified type
generic_txn = ctx.any_transaction(
    type=algopy.TransactionType.Payment,  # Specified transaction type
    sender=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    receiver=ctx.any_account(),  # Defaults to a random account generated by ctx.any_account()
    amount=algopy.UInt64(1000000)  # Specified amount
)

class MyContract(algopy.ARC4Contract):
    ...
    @algopy.arc4.abimethod
    def my_method(self):
        ...
        return Txn.amount

# Setting transaction group with index of current executing transaction
ctx.set_transaction_group(gtxn=[pay_txn, asset_transfer_txn, app_call_txn], active_transaction_index=3)
# Now when you access abstractions like `algopy.Txn` to access 'current' transaction it will point to 'app_call_txn' at index 3.
contract = MyContract()
# Given that we set active transaction index to 3, the `Txn` reference will correctly refer to 'app_call_txn' instance.
assert contract.my_method() == algopy.UInt64(1000000)

## Note: active_transaction_index is optional, defaults to 0 and controls which transaction to consider when
## interacting with `algopy.Txn` and affects behaviour when invoking contract methods using `abimethod` or `baremethod` decorators.
## Refer to `ARC4Contract` and `Contract` sections for additional usage examples.

# Get the transaction group.
txn_group = ctx.get_transaction_group()

# Set the active transaction index
ctx.set_active_transaction_index(0)

# Get the active transaction
active_txn = ctx.get_active_transaction()

# Clear the transaction group
ctx.clear_transaction_group()
```

## Inner Transaction

Inner transactions are AVM transactions that are signed and executed by an AVM applications (instances of deployed smart contract/signatures). When testing smart contracts, you may interact and manage inner transactions via the test context manager as such:

```python
# Lets use a method borrowed from our auction contract from examples. The method performs an inner asset transfer.
# Hence after execution we expect the test context to automatically capture and store itxn.AssetTransfer transaction submitted by the contract method to be available for further unit testing assertions.
class AuctionContract(algopy.ARC4Contract):
    ...
    @arc4.abimethod
    def claim_asset(self, asset: Asset) -> None:
        ...
        itxn.AssetTransfer(
            xfer_asset=asset,
            asset_close_to=self.previous_bidder,
            asset_receiver=self.previous_bidder,
            asset_amount=self.asa_amount,
        ).submit()
    ...

... # instantiate test context and invoke contract method
contract = AuctionContract()
contract.claim_asset(asset=ctx.any_asset())

# Test context will automatically capture and store itxn.AssetTransfer transaction submitted by the contract method.
# To access the 'submitted' inner transaction with implicit assertions of whether any inner transaction has been submitted, and type of last submitted inner transaction is of specified type:
asset_transfer_txn = ctx.last_submitted_inner_txn.asset_transfer

# Alternatively you can access the entire group to retrieve a specific transaction or iterate over groups of transactions:
for txn in ctx.last_submitted_inner_txns:
    ...
## or
asset_transfer_txn_2 = ctx.get_submitted_itxn_group(0).asset_transfer(0) # since we expect only one asset transfer inner transaction to be submitted
# Note that above also performs type validation and will throw an error if the type of inner transaction at index is not of specified type.
```

See [Examples](../examples.md) for more examples of accessing inner transactions.
